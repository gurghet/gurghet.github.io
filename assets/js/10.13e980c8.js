(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{362:function(t,a,s){t.exports=s.p+"assets/img/design-draft-for-the-bitcoin-ticker.8a97413d.png"},363:function(t,a,s){t.exports=s.p+"assets/img/gomez-examining-a-stock-ticker.b61995f1.png"},391:function(t,a,s){"use strict";s.r(a);var e=s(9),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("Learning functional programming")]),t._v(" "),e("p",[t._v("Advanced track")])]),t._v(" "),e("p",[t._v("In this series I want to explore fundamental concepts and tools of functional programming by building small applications.")]),t._v(" "),e("h1",{attrs:{id:"streams"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#streams"}},[t._v("#")]),t._v(" Streams")]),t._v(" "),e("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/sXYceYCLUZw",frameborder:"0",allow:"autoplay; encrypted-media",allowfullscreen:""}}),t._v(" "),e("p",[t._v("A stream is a conceptual device that abstracts the way in wich we access and process data. A stream at its core is just a sequence of data. However, differently from an array or a list, a stream doesn't necessarily have a beginning or an end.")]),t._v(" "),e("p",[t._v("In real life we have some example of streams. A ticker for the price of Bitcoin for example. It's a stream because it's clearly a timed sequence of data. It does have a beginning (when Bitcoin was created) but it never ends.")]),t._v(" "),e("h2",{attrs:{id:"building-a-bitcoin-price-ticker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#building-a-bitcoin-price-ticker"}},[t._v("#")]),t._v(" Building a Bitcoin price ticker")]),t._v(" "),e("p",[t._v("In this issue you'll build a BTC ticker that runs on your screen. This way you will always know when to buy and when to sell.")]),t._v(" "),e("h3",{attrs:{id:"design"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[t._v("#")]),t._v(" Design")]),t._v(" "),e("div",{staticStyle:{margin:"20px"}},[e("img",{attrs:{alt:"Design draft for the BTC ticker",src:s(362),height:"300"}})]),t._v(" "),e("p",[t._v("A simple design you can draft in two seconds is the one sketched above. We'll chose some API, parse the output, turn it into a number and finally print it on our screen (or physical ticker if you are retro).")]),t._v(" "),e("p",[e("img",{attrs:{src:s(363),alt:"Gomez Addams inspecting a stock ticker"}})]),t._v(" "),e("h3",{attrs:{id:"programming"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#programming"}},[t._v("#")]),t._v(" Programming")]),t._v(" "),e("p",[t._v("A very first draft of the program might be like this:")]),t._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[t._v("ZStream\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("repeat"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"100.000"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// generate some fake data")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("take"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// let's not overload")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("map"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("identity"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// placeholder for parsing")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("map"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("priceString "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v(" BigDecimal"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("priceString"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foreach"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("price "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v("\n    putStrLn"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      s"),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"BTC-EUR: ${price.setScale(2, BigDecimal.RoundingMode.UP)}"')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("You can go ahead and "),e("a",{attrs:{href:"https://scastie.scala-lang.org/hwQEk38eTOCfYYrEjhne2Q",target:"_blank",rel:"noopener noreferrer"}},[t._v("launch this"),e("OutboundLink")],1),t._v(". In the first line we are getting a hold of the "),e("code",[t._v("ZStream")]),t._v(" object, it contains the "),e("code",[t._v("repeat")]),t._v(" method wich just infinitely produces whatever we pass: a string in this case. We limit it to 3 strings, otherwise it will just overload our machine and never stop. The parsing for now is impersonated by an identity function. We then leverage the "),e("code",[t._v("BigDecimal")]),t._v(" parsing capabilities to have a number to work with. Lastly the "),e("code",[t._v("foreach")]),t._v(" method is used, which is a terminal method. It will wrap up the stream by printing on the screen a well formatted price tick.")]),t._v(" "),e("p",[t._v("We could have even skipped the conversion to "),e("code",[t._v("BigDecimal")]),t._v(" and back if we don't care about having control on rounding.")]),t._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[t._v("ZStream\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("repeat"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"100.000"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("take"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("map"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("identity"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foreach"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("price "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v(" putStrLn"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"BTC-EUR: $price"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("Now we go hunting for a good API. Like in the cooking TV show I’ve already done this, but you can look for yourself and I recommend "),e("a",{attrs:{href:"https://www.programmableweb.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ProgrammableWeb"),e("OutboundLink")],1),t._v(".")]),t._v(" "),e("p",[t._v("I’m going to use the "),e("a",{attrs:{href:"https://api.kraken.com/0/public/Ticker?pair=BTCEUR",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kraken public API"),e("OutboundLink")],1),t._v(" which is very basic. It returns a json of this form:")]),t._v(" "),e("div",{staticClass:"language-json extra-class"},[e("pre",{pre:!0,attrs:{class:"language-json"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"error"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"result"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"XXBTZEUR"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            ... other stuff\n            "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"c"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"last trade price"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            ... other stuff\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("We are interested in the current price which is the last trade price. We could (and should) use a json parser to extract this. However that would open a can of worms, so I’m going to use a regular expression:\n")]),t._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" parsePrice"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("json"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("String")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" regex "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" raw"),e("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v('"""(?s).*"c":\\["([0-9.]+).*"""')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("r\n  json "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" regex"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("price"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v(" price\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("So we have our parsing step, we finally need to actually call the API. Again, there are super-cool http clients we could use; instead for simplicity's sake we'll use the scala built-in client.")]),t._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" tickerURLCall"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Task"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" IO"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  io"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Source\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fromURL"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"https://api.kraken.com/0/public/Ticker?pair=BTCEUR"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mkString\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("We can now put everything together in the program. We will use "),e("code",[t._v("tickerURLCall")]),t._v(" instead of the fake data and the "),e("code",[t._v("priceParce")]),t._v(" instead of the identity.")]),t._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" program"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ZIO"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Console "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v(" Clock"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Throwable"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Unit")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ZStream\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("repeatEffect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("tickerURLCall"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("throttleShape"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5.")]),t._v("seconds"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_ "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// let's slow down")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("map"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parsePrice"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foreach"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("price "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v("\n      putStrLn"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        s"),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"BTC-EUR: $price"')]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("Node the addition of the "),e("code",[t._v("throttleShape")]),t._v(" function. This is because we don't want to call the API as fast as we can, but we want a constant slow rate. The code says 1 call every 5 seconds. The function we supply in the second pair of brakets is a function to compute the weight of the result (to shape the throttle accordingly) we conside all responses equal to 1.")]),t._v(" "),e("p",[t._v("This last feature is useful if you have pagination and you don't know how many items you have for each page. You could create a stream that outputs 10 items per minute and sometimes the calls to the source API return more (or less). Then the API would be called more slowly (or faster) to compensate.")]),t._v(" "),e("p",[t._v("Also we don't need to limit the number of ticks with "),e("code",[t._v("take(3)")]),t._v(" now that we have throttling in place.")]),t._v(" "),e("p",[t._v("You can "),e("a",{attrs:{href:"https://scastie.scala-lang.org/8nRhWur0TEqgSbfayn3JOA",target:"_blank",rel:"noopener noreferrer"}},[t._v("test the bitcoin ticker on Scastie"),e("OutboundLink")],1),t._v(" remember to edit it to display your favourite currency pair and your favourite rounding.")])])}),[],!1,null,null,null);a.default=n.exports}}]);